**Распаковка кортежа и кортеж как записи**

Распаковка кортежа или iterable unpacking это когда каждому элементу кортежа присваевается переменная:
a, b, c, d = (1, 2, 3, 4)
a = 1
b = 2
c = 3
d = 4
Элегантное применение распаковки кортежа – обмен значений двух переменных без создания временной переменной: 
\>>> b, a = a, b
Другой пример – звездочка перед аргументом при вызове функции:
\>>> divmod(20, 8) 
(2, 4) 
\>>> t = (20, 8) 
\>>> divmod(*t) 
(2, 4)

Так же можно очень удобно ловить нужные значения из функций возвращающие кортеж:
\>>> import os 
\>>> _, filename = os.path.split('/home/luciano/.ssh/idrsa.pub') 
возвратило кортеж (path, last_part)
откуда мы взяли только last_part и присвоили его в переменную file_name, а \_ мы опустили не нужную нам часть возвращенного кортежа (Заменили на фиктивную переменную)
\>>> filename 
\>>> 'idrsa.pub'

**Использование \* для выборки лишних элементов**

Простой пример для выборки элементов через \* это:
\>>> a, b, *rest = range(5) 
\>>> a, b, rest 
\>>> (0, 1, [2, 3, 4])

Видно что в a и b переменные присваиваются первые значения из функции range которая возвращает кортеж, а в переменнуб rest кладётся остаток этого кортежа.

\>>> a, b, *rest = range(2) 
\>>> a, b, rest 
\>>> (0, 1, [])

**Именованные кортежи**

Функция collection.namedtuple - это фабрика, порождающая подклассы tuple, дополненные возможностью задавать имена полей и имя класса.

(Так же бонусом, экземпляры класса namedtuple, потребляют ровно столько памяти, сколько кортежи, потому что имена полей хранятся в определении класса. При этом они занимают меньше памяти, чем обычные объекты, так как атрибуты не хранятся в атрибуте \_\_dict\_\_ на уровне экземпляра)
\>>> from collections import namedtuple 
\>>> City = namedtuple('City', 'name country population coordinates')
\>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))
\>>> tokyo 
\>>> City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667)) 
\>>> tokyo.population
\>>> 36.933 
\>>> tokyo.coordinates (35.689722, 139.691667) 
\>>> tokyo[1]
\>>>  'JP'
Для создания им. кортежа нужно задать два параметра: имя класса и список имен полей; последний может быть любым итерируемым объектом, содержащим строки, иои одной строкой, в которой имена перечисленны через запятую.
Данные передаются конструктору в виде позиционных аргументов, тогда как конструктор кортежа принимает единственный итерируемый объект.
К полям можно обращаться по имени или по номеру позиции.

**Кортежи как неизменяемые списки**
Тип tuple очень похож на list, поддерживает такие же методы как и у list только без добавления и удаления и так же у tuple отсутствует метод reversed. Но это просто оптимизация, reversed(tuple) работает и без него.

**Получения срезов у list, tuple, str и др типов последовательностей**
Нотация [a:b:c] допустима только внутри квадратных скобок и порождает объект slice(a:b:c).

**Многомерные срезы и многоточия**

Оператор [] может принимать несколько индексов или срезов, разделенных запятыми. Это используется, например, в стороннем NumPy, где для получения однгого элемента двумерного массива, применяется нотация a[i, j], а для получения двумерного среза - нотация a[m:n, k:l]. Специальные методы \__getittem\__ и \__setitem\__, на которых основан оператор [], просто принимают индексы, заданные в выражении a[i, j], в виде кортежа. Иначе говоря a[i, j] python вызывает a.\__getittem\__((i, j)).
В python встроенны только одномерные типы последовательностей, по этому они поддерживают только лишь один индекс или диапазон, а не кортеж.

В многомерных масивах, например в библиотеке NumPy используются многоточия (как три точки) для обозначения:
x[i, ... ] == x[i, :, :, :,] в обычном python объекты Ellipsis или многомерных индексов не применяются.
Срезы полезны не только для выборки частей, они позволяют модифицировать изменяемые последовательности на месте, т.е не перестраивая их с нуля.

**Присваивание срезу**

Срезу можно присвоить значения. Например:
\>>> l = list(range(10))
\>>> l
\>>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\>>> l[2:5] = [20, 30]
\>>> l
\>>> [0, 1, 20, 30, 5, 6, 7, 8, 9]

Когда в левой части стоит срез, в правой части должен быть итерируемый объект.

**Использование + и \* для последовательностей**

При использовании конкатинации для последовательностей создается новая последовательность(новый объект).
\>>> l = [1, 2, 3]
\>>> l * 5
\>>> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] (новая последовательность)
\>>> 5 * 'abcd'
\>>> 'abcdabcdabcdabcdabcd' (новая последовательность)
Операторы + и \* всегда создают новый объект и никогда не изменяют свои операнды

Следует остерегаться вещей вида а \* n , где а это последовательность. Так как при попытке инициализировать список способом my_list = \[[]\] \* 3 , получится список содержащий 3 ссылки на один и тот же объект.

**Построение списка списков**

board = [['_'] * 3 for i in range(3)]

При использовании такого подхода создания вложенных списков, внутри списка будут содержаться разные объекты списков. То есть они будт разными объектами и с ними можно буджет взаимодействовать как с индивидуальными вложенными списками.

weird_board = [['_'] * 3] * 3

При таком подходе создания вложенных списков, будут созданы 3 списка, которые будуто одним и тем же объектом. Любые операции с такими влож. списками будут изменять все 3 списка. (Т.к один и тот же объект)

При детальном рассмотрении:

2 способ выглядит так:

row = ['_'] * 3 
board = []
for i in range(3):
	board.append(row)
	
Один и тот же список роу добавляется в список боард.
	
1 способ выглядит так:

board = []
for i in range(3):
	row = ['_'] * 3
	board.append(row)

Каждый раз строится новый список роу и добавляется в конец списка боард.

**Составное присваивание последовательностей**

• Не стоит помещать изменяемые элементы в кортежи.
• Составное присваивание – не атомарная операция; мы только что видели, как она возбуждает исключение, проделав часть работы.
• Изучить байт-код не так уж трудно, и часто это помогает понять, что происходит под капотом. 

**Метод list.sort и встроенная функция sorted**

Метод list.sort сортирует список на месте, т.е не создавая копию. Он возвращает None , напоминая что изменяет объект, а не создает новый список.
__Это важное соглашение в Python API: функции и методы, изменяющие объект на месте, должны возвращать None__ Например таж же действует функиция random.shuffle.

(У соглашения о возврате None в случае обновления на месте есть недостаток: такие методы невозможно соединить в цепочку. Напротив, методы, возвращающие новые объекты (например, все методы класса str), можно сцеплять, получая тем самым «текучий» интерфейс)

С другой сстороны, встроенная функция sorted создаёт и возвращает новый список. На самом деле она принимает любой итерируемый объект, даже если он неизменяемый. Не зависимо от типа объекта, она возвращает новый список.

И метод list.sort и функция sorted принимают два необязательных именованных аргумента: 
__reverse__ - если True , то элементы возвращаются в порядке убывания. По умолч. False.
__key__ - функция с одним аргументом, которая вызывается для каждого элемента и возвращает его ключ сортировки. Например key=str.lower, то строки будут сортироваться без учёта регистра, а если key=len, то по длине в символах.

(Необязательный именованный параметр key можно также использовать совместно с встроенными функциями min() и max() и другими функциями из стандартной библиотеки (например, itertools.groupby() или heapq.nlargest()).)

**Средства работы с упорядоченными последовательностями в модуле bisect**

