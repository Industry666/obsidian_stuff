**Распаковка кортежа и кортеж как записи**

Распаковка кортежа или iterable unpacking это когда каждому элементу кортежа присваевается переменная:
a, b, c, d = (1, 2, 3, 4)
a = 1
b = 2
c = 3
d = 4
Элегантное применение распаковки кортежа – обмен значений двух переменных без создания временной переменной: 
\>>> b, a = a, b
Другой пример – звездочка перед аргументом при вызове функции:
\>>> divmod(20, 8) 
(2, 4) 
\>>> t = (20, 8) 
\>>> divmod(*t) 
(2, 4)

Так же можно очень удобно ловить нужные значения из функций возвращающие кортеж:
\>>> import os 
\>>> _, filename = os.path.split('/home/luciano/.ssh/idrsa.pub') 
возвратило кортеж (path, last_part)
откуда мы взяли только last_part и присвоили его в переменную file_name, а \_ мы опустили не нужную нам часть возвращенного кортежа (Заменили на фиктивную переменную)
\>>> filename 
\>>> 'idrsa.pub'

**Использование \* для выборки лишних элементов**

Простой пример для выборки элементов через \* это:
\>>> a, b, *rest = range(5) 
\>>> a, b, rest 
\>>> (0, 1, [2, 3, 4])

Видно что в a и b переменные присваиваются первые значения из функции range которая возвращает кортеж, а в переменнуб rest кладётся остаток этого кортежа.

\>>> a, b, *rest = range(2) 
\>>> a, b, rest 
\>>> (0, 1, [])

**Именованные кортежи**

Функция collection.namedtuple - это фабрика, порождающая подклассы tuple, дополненные возможностью задавать имена полей и имя класса.

(Так же бонусом, экземпляры класса namedtuple, потребляют ровно столько памяти, сколько кортежи, потому что имена полей хранятся в определении класса. При этом они занимают меньше памяти, чем обычные объекты, так как атрибуты не хранятся в атрибуте \_\_dict\_\_ на уровне экземпляра)
\>>> from collections import namedtuple 
\>>> City = namedtuple('City', 'name country population coordinates')
\>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))
\>>> tokyo 
\>>> City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667)) 
\>>> tokyo.population
\>>> 36.933 
\>>> tokyo.coordinates (35.689722, 139.691667) 
\>>> tokyo[1]
\>>>  'JP'
Для создания им. кортежа нужно задать два параметра: имя класса и список имен полей; последний может быть любым итерируемым объектом, содержащим строки, иои одной строкой, в которой имена перечисленны через запятую.
Данные передаются конструктору в виде позиционных аргументов, тогда как конструктор кортежа принимает единственный итерируемый объект.
К полям можно обращаться по имени или по номеру позиции.

**Кортежи как неизменяемые списки**
Тип tuple очень похож на list, поддерживает такие же методы как и у list только без добавления и удаления и так же у tuple отсутствует метод reversed. Но это просто оптимизация, reversed(tuple) работает и без него.

**Получения срезов у list, tuple, str и др типов последовательностей**
Нотация [a:b:c] допустима только внутри квадратных скобок и порождает объект slice(a:b:c).

**Многомерные срезы и многоточия**

Оператор [] может принимать несколько индексов или срезов, разделенных запятыми. Это используется, например, в стороннем NumPy, где для получения однгого элемента двумерного массива, применяется нотация a[i, j], а для получения двумерного среза - нотация a[m:n, k:l]. Специальные методы \__getittem\__ и \__setitem\__, на которых основан оператор [], просто принимают индексы, заданные в выражении a[i, j], в виде кортежа. Иначе говоря a[i, j] python вызывает a.\__getittem\__((i, j)).
В python встроенны только одномерные типы последовательностей, по этому они поддерживают только лишь один индекс или диапазон, а не кортеж.

В многомерных масивах, например в библиотеке NumPy используются многоточия (как три точки) для обозначения:
x[i, ... ] == x[i, :, :, :,] в обычном python объекты Ellipsis или многомерных индексов не применяются.
Срезы полезны не только для выборки частей, они позволяют модифицировать изменяемые последовательности на месте, т.е не перестраивая их с нуля.

**Присваивание срезу**
