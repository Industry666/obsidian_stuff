Ни один из этих методов при реализации их в классе не вызывается напрямую : object.____add____ , обычно их вызывает интерпретатор Python.
Для человека данные методы вызываются со специальными операторами *, + , abs(object) и т.д.

from math import hypot class Vector
def ____init____(self, x=0, y=0): 
self.x = x 
self.y = y
def ____repr____(self): 
return 'Vector(%r, %r)' % (self.x, self.y) 
def ____abs____(self):
return hypot(self.x, self.y)
def ____bool____(self): 
return bool(abs(self))
def ____add____(self, other):
x = self.x + other.x y = self.y + other.y return Vector(x, y)
def ____mul____(self, scalar): 
return Vector(self.x * scalar, self.y * scalar)


**Строковое представление**.

Специальный метод ____repr____ вызывается встроенной функцией repr для получение строкового преставления объекта. Если мы бы не реализовали его, то объект класса Vector был бы представлен в оболочке строкой вида: <Vector object at 0x10e100070>.
Интерактивная оболочка и отладчик вызывают функцию repr, передавая ей результат вычисления выражения. То же самое происходит при обработке спецификатора %r в случае классического форматирования с помощью оператора %.

В отличии от ____repr____, метод ____str____ вызывается конструктором str() и неявно используется в функции print(). Метод ____str____ должен возвращать строкупригодную для показу пользователям. 
Если мы реализуем один из этих методов, пусть это будет ____repr____, потому что в отсутствии пользовательского ____str____ интерпретатор вызовет ____repr____.


**Арефметические операторы.**

В примере реализованы 2 оператора : + и *. Отметим что оба метода создают и возвращают новый экземпляр Vector, не модифицируя ни один операнд, - аргументы self и other только читаются. Это ожидаемое поведение инфиксных оператороа: создавать новые объекты, не трогая операнды.

(В примере 1.2 реализовано умножение объекта Vector на число, но не числа на объект Vector, что нарушает свойство коммутативности умножения. В главе 13 мы исправим этот недочет с помощью специального метода ____rmul____.)


**Булево значение пользовательского типа**.

Чтобы определить, является ли выражение истинным или ложным, применяется функция bool(x), которая возвращает True или False.
По умолчанию любой объект пользовательского класса считается истинным, но положение меняется, если реализован хотя бы один из методов ____bool____ или ____len____. Функция bool(x), по существу вызывает x.____bool____() и использует полученный результат. Если метод ____bool____ не реализован, то Python пытается вызвать x.____len____ и при получении нуля функция bool возвращает 0. В противном случае True.

В примере реализация ____bool____ проста: метод возвращает False если модуль вектора равен 0, и True в противном случае. Для преобразования в булеву величину мы вызываем bool(abs(self)), по скольку ожидается что метод ____bool____ возвращает булево значение.

(Можно было бы написать более быструю реализацию метода Vector.__bool__: def __bool__(self): return bool(self.x or self.y) Она сложнее воспринимается, зато позволяет избежать обращений к abs и __abs__, возведения в квадрат и извлечения корня. Явное преобразование в тип bool необходимо, потому что метод __bool__ должен возвращать булево значение, а оператор or возвращает один из двух операндов: результат вычисления x or y равен x, если x истинно, иначе равен y вне зависимости от его значения.)

**len - не метод.** 

Основная идея в том что len(x) не метод потому что у встроенных типов данных читаются значения которая хранится в поле структуры CPython.
Но благодаря ____len____ можно вызывать функцию len() и для пользовательского объекта.
